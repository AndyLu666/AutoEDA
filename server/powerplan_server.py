#!/usr/bin/env python3

from typing import Optional
import subprocess
import pathlib
import datetime
import os
import logging
import sys
import gzip
import glob
import argparse                    
from fastapi import FastAPI
from pydantic import BaseModel

# Setup logging and paths
ROOT = pathlib.Path(__file__).resolve().parent.parent
LOG_ROOT = pathlib.Path(os.getenv("LOG_ROOT", str(ROOT / "logs")))
LOG_ROOT.mkdir(exist_ok=True)
LOG_DIR = LOG_ROOT / "powerplan"            
LOG_DIR.mkdir(parents=True, exist_ok=True)

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler(LOG_ROOT / "pwr_api.log"), 
        logging.StreamHandler(sys.stdout),
    ],
)

class PwrReq(BaseModel):
    design: str
    tech: str = "FreePDK45"
    impl_ver: str
    restore_enc: str      
    force: bool = False
    top_module: Optional[str] = None

    # User input parameters (previously from CSV)
    design_flow_effort: str = "standard"  # express, standard
    design_power_effort: str = "none"     # none, medium, high
    target_util: float = 0.7              # target utilization

class PwrResp(BaseModel):
    status: str
    log_path: str
    report: str
    tcl_path: str = ""

def parse_top_from_config(cfg: pathlib.Path) -> str:
    """Parse TOP_NAME from config.tcl file"""
    if not cfg.exists():
        return ""
    for line in cfg.read_text().splitlines():
        if line.strip().startswith("set TOP_NAME"):
            return line.split('"')[1]
    return ""

def generate_complete_powerplan_tcl(req: PwrReq, result_dir: pathlib.Path, restore_enc: pathlib.Path, top_name: str) -> pathlib.Path:
    """Generate a complete powerplan TCL script with all necessary configurations"""
    
    # Read design config
    design_config_path = ROOT / "designs" / req.design / "config.tcl"
    design_config_content = ""
    if design_config_path.exists():
        design_config_content = design_config_path.read_text()
    
    # Read tech config
    tech_tcl_path = ROOT / "scripts" / req.tech / "tech.tcl"
    tech_content = ""
    if tech_tcl_path.exists():
        tech_content = tech_tcl_path.read_text()
    
    # Read powerplan script
    powerplan_script_path = ROOT / "scripts" / req.tech / "backend" / "3_powerplan.tcl"
    powerplan_content = ""
    if powerplan_script_path.exists():
        powerplan_content = powerplan_script_path.read_text()
    
    # Define template variables for replacement
    template_variables = {
        "${TOP_NAME}": top_name,
        "$TOP_NAME": top_name,
        "${design_flow_effort}": req.design_flow_effort,
        "$design_flow_effort": req.design_flow_effort,
        "${design_power_effort}": req.design_power_effort,
        "$design_power_effort": req.design_power_effort,
        "${target_util}": str(req.target_util),
        "$target_util": str(req.target_util),
    }
    
    # Apply template variable replacements
    for placeholder, value in template_variables.items():
        tech_content = tech_content.replace(placeholder, value)
    
    for placeholder, value in template_variables.items():
        design_config_content = design_config_content.replace(placeholder, value)
    
    for placeholder, value in template_variables.items():
        powerplan_content = powerplan_content.replace(placeholder, value)
    
    # Build environment variables from request parameters
    env_vars = {
        "BASE_DIR": str(ROOT),
        "TOP_NAME": top_name,
        "FILE_FORMAT": "verilog",
        "version": "custom",
        "design_flow_effort": req.design_flow_effort,
        "design_power_effort": req.design_power_effort,
        "target_util": str(req.target_util),
    }
    
    # Generate complete TCL content
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    tcl_content = f"""#===============================================================================
# Complete Powerplan TCL Script
# Generated by MCP EDA Server
# Design: {req.design}
# Tech: {req.tech}
# Implementation Version: {req.impl_ver}
# Generated at: {timestamp}
#===============================================================================

#-------------------------------------------------------------------------------
# Environment Variables Configuration
#-------------------------------------------------------------------------------
"""
    
    # Add environment variables
    for var, value in env_vars.items():
        tcl_content += f'set env({var}) "{value}"\n'
    
    tcl_content += f"""
#-------------------------------------------------------------------------------
# Set Global Variables
#-------------------------------------------------------------------------------
set TOP_NAME "{top_name}"
set FILE_FORMAT "verilog"

#-------------------------------------------------------------------------------
# Create Output Directories
#-------------------------------------------------------------------------------
file mkdir pnr_logs
file mkdir pnr_out
file mkdir pnr_reports
file mkdir pnr_save

#-------------------------------------------------------------------------------
# Design Config (from config.tcl)
#-------------------------------------------------------------------------------
{design_config_content}

#-------------------------------------------------------------------------------
# Technology Configuration (from tech.tcl)
#-------------------------------------------------------------------------------
{tech_content}

#-------------------------------------------------------------------------------
# Restore Design
#-------------------------------------------------------------------------------
restoreDesign "{restore_enc.resolve()}" {top_name}

#===============================================================================
# Powerplan Script: 3_powerplan.tcl
#===============================================================================

{powerplan_content}

# Generate powerplan report
summaryReport -outfile pnr_reports/powerplan.rpt
exec gzip pnr_reports/powerplan.rpt &

# Mark completion
exec touch _Done_

"""

    # Write TCL file
    tcl_file = result_dir / f"complete_powerplan.tcl"
    tcl_file.write_text(tcl_content)
    
    return tcl_file

def setup_powerplan_workspace(req: PwrReq, log_file: pathlib.Path) -> tuple[bool, str, pathlib.Path]:
    """Setup powerplan workspace directory"""
    
    des_root = ROOT / "designs" / req.design / req.tech
    impl_dir = des_root / "implementation" / req.impl_ver
    
    if not impl_dir.exists():
        return False, "implementation directory not found", impl_dir
    
    # Check if directories exist, create if needed
    required_dirs = ["pnr_logs", "pnr_out", "pnr_reports", "pnr_save"]
    for dir_name in required_dirs:
        dir_path = impl_dir / dir_name
        dir_path.mkdir(exist_ok=True)
    
    # Copy config.tcl if it exists
    config_src = ROOT / "designs" / req.design / "config.tcl"
    config_dst = impl_dir / "config.tcl"
    if config_src.exists() and not config_dst.exists():
        config_dst.write_text(config_src.read_text())
    
    return True, "workspace setup successful", impl_dir

def call_powerplan_executor(tcl_file: pathlib.Path, workspace_dir: pathlib.Path, req: PwrReq, log_file: pathlib.Path) -> tuple[bool, str, dict]:
    """Call powerplan executor to run the generated TCL"""
    
    executor_path = ROOT / "server" / "powerplan_Executor.py"
    
    # Build environment variables
    env = os.environ.copy()
    env.update({
        "BASE_DIR": str(ROOT),
        "TOP_NAME": req.top_module or req.design,
        "FILE_FORMAT": "verilog", 
        "version": "custom",
        "design_flow_effort": req.design_flow_effort,
        "design_power_effort": req.design_power_effort,
        "target_util": str(req.target_util),
    })
    
    # Add EDA tool paths
    eda_tool_paths = [
        "/opt/cadence/innovus221/tools/bin",
        "/opt/cadence/genus172/bin"
    ]
    current_path = env.get("PATH", "")
    env["PATH"] = ":".join(eda_tool_paths + [current_path])
    
    # Build executor command
    cmd = [
        "python", str(executor_path),
        "-mode", "powerplan",
        "-design", req.design,
        "-technode", req.tech,
        "-tcl", str(tcl_file),
        "-workspace", str(workspace_dir)
    ]
    
    if req.force:
        cmd.extend(["-force"])
    
    try:
        with log_file.open("a") as lf:
            lf.write(f"\n=== Starting Powerplan Executor ===\n")
            lf.write(f"Command: {' '.join(cmd)}\n")
            lf.write(f"Working directory: {workspace_dir}\n")
            lf.flush()
            
            process = subprocess.Popen(
                cmd,
                cwd=workspace_dir,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                env=env,
                shell=False,
                executable=None
            )
            
            # Stream output to log file
            for line in process.stdout:
                lf.write(line)
                lf.flush()
            
            process.wait()
            
            lf.write(f"\n=== Powerplan Executor completed with return code: {process.returncode} ===\n")
        
        if process.returncode != 0:
            return False, f"Powerplan executor failed with return code {process.returncode}", {}
        
        # Check for completion marker
        done_file = workspace_dir / "_Done_"
        if not done_file.exists():
            return False, "Powerplan did not complete successfully (_Done_ file not found)", {}
        
        return True, "Powerplan completed successfully", {}
        
    except Exception as e:
        return False, f"Error running powerplan executor: {str(e)}", {}

app = FastAPI(title="MCP Â· Power-plan Service")

@app.post("/run", response_model=PwrResp)
def run_powerplan(req: PwrReq):
    """Main powerplan endpoint using server-executor architecture"""
    
    ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    log_file = LOG_DIR / f"{req.design}_powerplan_{ts}.log"
    
    try:
        with log_file.open("w") as lf:
            lf.write(f"=== MCP EDA Powerplan Service ===\n")
            lf.write(f"Design: {req.design}\n")
            lf.write(f"Tech: {req.tech}\n")
            lf.write(f"Implementation Version: {req.impl_ver}\n")
            lf.write(f"Restore ENC: {req.restore_enc}\n")
            lf.write(f"Force: {req.force}\n")
            lf.write(f"Started at: {datetime.datetime.now()}\n\n")
        
        # Validate restore_enc file
        restore_enc = pathlib.Path(req.restore_enc)
        if not restore_enc.exists():
            return PwrResp(
                status="error: floorplan.enc.dat not found",
                log_path=str(log_file),
                report="",
                tcl_path=""
            )
        
        # Parse TOP_NAME
        cfg_path = ROOT / "designs" / req.design / "config.tcl"
        if req.top_module:
            top_name = req.top_module
        else:
            parsed = parse_top_from_config(cfg_path)
            top_name = parsed if parsed else req.design
        
        # Step 1: Setup workspace
        success, message, workspace_dir = setup_powerplan_workspace(req, log_file)
        if not success:
            return PwrResp(
                status=f"error: {message}",
                log_path=str(log_file),
                report="",
                tcl_path=""
            )
        
        # Step 2: Generate complete TCL
        result_dir = ROOT / "result" / req.design / req.tech
        result_dir.mkdir(parents=True, exist_ok=True)
        
        tcl_file = generate_complete_powerplan_tcl(req, result_dir, restore_enc, top_name)
        
        with log_file.open("a") as lf:
            lf.write(f"Generated TCL file: {tcl_file}\n")
        
        # Step 3: Call executor
        success, message, result_data = call_powerplan_executor(tcl_file, workspace_dir, req, log_file)
        
        if not success:
            return PwrResp(
                status=f"error: {message}",
                log_path=str(log_file),
                report="",
                tcl_path=str(tcl_file)
            )
        
        # Step 4: Collect report
        report_text = "powerplan.rpt(.gz) not found"
        rpt_dir = workspace_dir / "pnr_reports"
        rpt_file = rpt_dir / "powerplan.rpt"
        
        if rpt_file.exists():
            report_text = rpt_file.read_text(errors="ignore")
        else:
            for cand in glob.glob(str(rpt_dir / "powerplan.rpt*")):
                p = pathlib.Path(cand)
                if p.suffix == ".gz":
                    with gzip.open(p, "rt") as f:
                        report_text = f.read()
                else:
                    report_text = p.read_text(errors="ignore")
                break
        
        with log_file.open("a") as lf:
            lf.write(f"\n=== Powerplan Service Completed Successfully ===\n")
            lf.write(f"Completed at: {datetime.datetime.now()}\n")
        
        return PwrResp(
            status="ok",
            log_path=str(log_file),
            report=report_text,
            tcl_path=str(tcl_file)
        )
        
    except Exception as e:
        error_msg = f"Unexpected error: {str(e)}"
        with log_file.open("a") as lf:
            lf.write(f"\n=== ERROR ===\n{error_msg}\n")
        
        return PwrResp(
            status=f"error: {error_msg}",
            log_path=str(log_file),
            report="",
            tcl_path=""
        )

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--port",
        type=int,
        default=int(os.getenv("POWERPLAN_PORT", 13336)),
        help="listen port (env POWERPLAN_PORT overrides; default 13336)",
    )
    args = parser.parse_args()

    import uvicorn
    uvicorn.run(
        "powerplan_server:app",
        host="0.0.0.0",
        port=args.port,
        reload=False,
    )