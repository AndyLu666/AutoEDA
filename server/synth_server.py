#!/usr/bin/env python3
# curl -X POST http://localhost:15333/run -H "Content-Type: application/json" -d '{"design": "des", "tech": "FreePDK45"}' | python -m json.tool

import subprocess, datetime, os, argparse
from pathlib import Path
from fastapi import FastAPI
from pydantic import BaseModel
from jinja2 import Template

# Load environment variables from .env file at project root
from dotenv import load_dotenv

# Add project root to Python path
ROOT = Path(__file__).resolve().parent.parent
load_dotenv(dotenv_path=ROOT / ".env")

LOG_DIR = Path(os.getenv("LOG_ROOT", str(ROOT / "logs"))) / "synthesis"
LOG_DIR.mkdir(parents=True, exist_ok=True)

class SynthReq(BaseModel):
    syn_version: str = None  # identifier for the synthesis run
    design: str  # design_name
    tech: str = "FreePDK45"  # library_name
    period: float = 1.0  #  ≥ 0
    fanout_value: float = 10.0  # ≥ 0
    transition_value: float = 0.2  # ≥ 0
    capacitance_value: float = 4.5  # ≥ 0
    compile_cmd: str = "compile"  
    power_effort: str = "none"  # none, low, medium, high
    area_effort: str = "none"  # none, low, medium, high
    map_effort: str = "low"  # low, medium, high
    dynamic_optimization: str = "false"  # true, false
    leakage_optimization: str = "false"  # true, false
    force: bool = True # overwrite existing results
    skip_execution: bool = False  # control execution skipping

class SynthResp(BaseModel):
    status: str
    log_path: str
    reports: dict
    tcl_path: str

def generate_complete_synthesis_tcl(req: SynthReq, result_dir: Path) -> Path:
    """Generate complete synthesis TCL script with all configurations filled"""
    
    design_config = ROOT / "designs" / req.design / "config.tcl"
    
    frontend_dir = ROOT / "scripts" / req.tech / "frontend"
    if not frontend_dir.exists():
        raise FileNotFoundError(f"Frontend directory not found: {frontend_dir}")
    
    # Get all TCL files in frontend directory, sorted by name
    frontend_scripts = sorted([f for f in frontend_dir.iterdir() if f.suffix == '.tcl'])
    if not frontend_scripts:
        raise FileNotFoundError(f"No TCL scripts found in: {frontend_dir}")
    
    # Read and combine all frontend scripts
    combined_frontend_content = ""
    for script_path in frontend_scripts:
        with open(script_path, "r") as f:
            script_content = f.read()
            combined_frontend_content += f"#===============================================================================\n"
            combined_frontend_content += f"# Frontend Script: {script_path.name}\n"
            combined_frontend_content += f"#===============================================================================\n\n"
            combined_frontend_content += script_content + "\n\n"
    
    # Replace the template's completion marker with our own (in the last script)
    # combined_frontend_content = combined_frontend_content.replace(
    #     "exec touch _Finished_\n\nexit",
    #     "# Synthesis completed\nexec touch _Done_\n\nexit"
    # )
    
    # Read tech.tcl content
    tech_tcl_path = ROOT / "scripts" / req.tech / "tech.tcl"
    if not tech_tcl_path.exists():
        raise FileNotFoundError(f"Tech file not found: {tech_tcl_path}")
        
    with open(tech_tcl_path, "r") as f:
        tech_content = f.read()
    
    # Read design config.tcl content  
    if not design_config.exists():
        raise FileNotFoundError(f"Design config not found: {design_config}")
        
    with open(design_config, "r") as f:
        design_config_content = f.read()
    
    # Replace template variables in frontend content
    combined_frontend_content = Template(combined_frontend_content).render(**vars(req))

    # Generate complete synthesis TCL content
    tcl_content = f"""#===============================================================================
# Complete Synthesis TCL Script
# Generated by MCP EDA Server
# Design: {req.design}
# Tech: {req.tech}
# Version: {req.syn_version}
# Generated at: {datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
#==============================================================================="""
    
    tcl_content += f"""
#-------------------------------------------------------------------------------
# Design Config (from config.tcl)
#-------------------------------------------------------------------------------
{design_config_content}

#-------------------------------------------------------------------------------
# Technology Configuration (from tech.tcl)
#-------------------------------------------------------------------------------
{tech_content}

#-------------------------------------------------------------------------------
# Frontend Scripts (from scripts/{req.tech}/frontend/)
#-------------------------------------------------------------------------------
{combined_frontend_content}"""

    tcl_path = result_dir / "complete_synthesis.tcl"
    tcl_path.write_text(tcl_content)

    return tcl_path

def setup_synthesis_workspace(req: SynthReq, log_file: Path) -> tuple[bool, str, Path]:
    """Setup synthesis workspace directory structure"""
    
    try:
        # Create directories structure
        design_dir = ROOT / "designs" / req.design
        synthesis_dir = design_dir / req.tech / "synthesis"
        syn_version_dir = synthesis_dir / req.syn_version
        
        # Check if version directory already exists
        if syn_version_dir.exists():
            if not req.force:
                with log_file.open("w") as lf:
                    lf.write(f"=== Synthesis Workspace Setup ===\n")
                    lf.write(f"[Warning] {syn_version_dir} already exists! Skipped...\n")
                return True, "workspace created (already existed)", syn_version_dir
            else:
                # Force overwrite - remove existing directory
                import shutil
                shutil.rmtree(syn_version_dir)
        
        # Create synthesis version directory
        syn_version_dir.mkdir(parents=True, exist_ok=True)
        
        with log_file.open("w") as lf:
            lf.write("=== Synthesis Workspace Setup ===\n")
            lf.write(f"Design: {req.design}\n")
            lf.write(f"Tech: {req.tech}\n")
            lf.write(f"Synthesis Version: {req.syn_version}\n")
            lf.write(f"Created workspace: {syn_version_dir}\n")
            lf.write("Workspace setup completed successfully.\n")

        return True, "workspace created", syn_version_dir

    except Exception as e:
        return False, f"error: {e}", None

def call_synthesis_executor(tcl_file: Path, workspace_dir: Path, req: SynthReq, log_file: Path) -> tuple[bool, str, dict]:
    """Call the synthesis executor to run EDA tools"""
    
    try:
        # Build executor command
        executor_path = ROOT / "server" / "synth_Executor.py"
        cmd = [
            "python", str(executor_path),
            "-mode", "synthesis",
            "-design", req.design,
            "-technode", req.tech,
            "-tcl", str(tcl_file),
            "-workspace", str(workspace_dir)
        ]
        
        # Set up environment
        env = os.environ.copy()
        env['BASE_DIR'] = str(ROOT)
        
        with log_file.open("a") as lf:
            lf.write("\n=== Calling Synthesis Executor ===\n")
            lf.write(f"Executor: {executor_path}\n")
            lf.write(f"TCL File: {tcl_file}\n")
            lf.write(f"Workspace: {workspace_dir}\n")
            lf.write(f"Command: {' '.join(cmd)}\n\n")
            
            # Execute the synthesis using executor
            process = subprocess.Popen(
                cmd,
                cwd=str(ROOT),
                universal_newlines=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                env=env,
            )
            for line in process.stdout:
                lf.write(line)
            process.wait()

        if process.returncode != 0:
            return False, f"error: executor failed with code {process.returncode}", {}

        # Check for completion marker
        done_file = workspace_dir / "_Finished_"
        if not done_file.exists():
            return False, "error: synthesis did not complete successfully (_Finished_ file not found)", {}

        # Collect synthesis reports
        reports_dir = workspace_dir / "reports"
        reports = {}
        for rpt in ("qor.rpt", "timing.rpt", "area.rpt", "power.rpt"):
            rpt_path = reports_dir / rpt
            if rpt_path.exists():
                reports[rpt] = str(rpt_path)
            else:
                reports[rpt] = f"{rpt} not found"

        return True, "synthesis completed successfully", reports

    except Exception as e:
        return False, f"error: {e}", {}

app = FastAPI(title="MCP · Synthesis Server")

@app.post("/run", response_model=SynthResp)
def run_synthesis(req: SynthReq):
    """Main synthesis endpoint: TCL generation + executor call"""
    
    ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # Set syn_version if not provided by client
    if req.syn_version is None:
        req.syn_version = ts
    
    log_file = LOG_DIR / f"{req.design}_synthesis_{ts}.log"
    result_dir = ROOT / "result" / req.design / req.tech
    result_dir.mkdir(parents=True, exist_ok=True)
    
    try:
        # Phase 1: Setup workspace
        workspace_success, workspace_status, workspace_dir = setup_synthesis_workspace(req, log_file)
        if not workspace_success:
            return SynthResp(
                status=workspace_status,
                log_path=str(log_file),
                reports={"error": workspace_status},
                tcl_path=""
            )
        
        # Phase 2: Generate complete TCL file with all configurations
        tcl_file = generate_complete_synthesis_tcl(req, result_dir)
        
        # Phase 3: Call executor to run synthesis
        if req.skip_execution:
            # Skip execution, just return TCL generation results
            final_reports = {
                "workspace": workspace_status, 
                "synthesis": "skipped_execution",
                "note": "TCL generation only - execution skipped"
            }
            exec_success = True
            exec_status = "execution_skipped"
        else:
            # Normal execution
            exec_success, exec_status, reports = call_synthesis_executor(tcl_file, workspace_dir, req, log_file)
            
            if not exec_success:
                return SynthResp(
                    status=exec_status,
                    log_path=str(log_file),
                    reports={"error": exec_status},
                    tcl_path=str(tcl_file)
                )
            
            final_reports = {"workspace": workspace_status, "synthesis": exec_status}
            final_reports.update(reports)
        
        return SynthResp(
            status="execution_completed",
            log_path=str(log_file),
            reports=final_reports,
            tcl_path=str(tcl_file)
        )

    except Exception as e:
        return SynthResp(
            status=f"error: {e}",
            log_path=str(log_file),
            reports={"error": str(e)},
            tcl_path=""
        )

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--port",
        type=int,
        default=int(os.getenv("SYN_PORT", 13333)),
        help="listen port (env SYN_PORT overrides; default 13333)",
    )
    args = parser.parse_args()

    import uvicorn
    uvicorn.run(
        "synth_server:app",
        host="0.0.0.0",
        port=args.port,
        reload=False,
        log_level="info",
    ) 